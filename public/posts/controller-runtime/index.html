<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Demystifying Kubernetes `controller-runtime` | Theddy Dev Space</title>
<meta name="keywords" content="k8s, kubernetes, operator, controller-runtime">
<meta name="description" content="If you&rsquo;re like me and just starting your Kubernetes journey, you&rsquo;ll likely need to write an Operator to manage your custom resources. Kubernetes offers a high-level Go framework called controller-runtime for building such operators; frameworks like Kubebuilder  are built on top of it. What do I mean by custom resources? Well, anything that you would create which is not part of the Kubernetes well-known built-in resources - Pods, Deployments, ReplicaSets, etc. An example might be you adding a new custom Backup resource whose main purpose is to do a scheduled cron job to upload backups to a desired target storage solution.">
<meta name="author" content="">
<link rel="canonical" href="https://theddy.dev/posts/controller-runtime/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://theddy.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://theddy.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://theddy.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://theddy.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://theddy.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://theddy.dev/posts/controller-runtime/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://theddy.dev/posts/controller-runtime/">
  <meta property="og:site_name" content="Theddy Dev Space">
  <meta property="og:title" content="Demystifying Kubernetes `controller-runtime`">
  <meta property="og:description" content="If you’re like me and just starting your Kubernetes journey, you’ll likely need to write an Operator to manage your custom resources. Kubernetes offers a high-level Go framework called controller-runtime for building such operators; frameworks like Kubebuilder are built on top of it. What do I mean by custom resources? Well, anything that you would create which is not part of the Kubernetes well-known built-in resources - Pods, Deployments, ReplicaSets, etc. An example might be you adding a new custom Backup resource whose main purpose is to do a scheduled cron job to upload backups to a desired target storage solution.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-09T18:15:00+03:00">
    <meta property="article:modified_time" content="2025-10-09T18:15:00+03:00">
    <meta property="article:tag" content="K8s">
    <meta property="article:tag" content="Kubernetes">
    <meta property="article:tag" content="Operator">
    <meta property="article:tag" content="Controller-Runtime">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Demystifying Kubernetes `controller-runtime`">
<meta name="twitter:description" content="If you&rsquo;re like me and just starting your Kubernetes journey, you&rsquo;ll likely need to write an Operator to manage your custom resources. Kubernetes offers a high-level Go framework called controller-runtime for building such operators; frameworks like Kubebuilder  are built on top of it. What do I mean by custom resources? Well, anything that you would create which is not part of the Kubernetes well-known built-in resources - Pods, Deployments, ReplicaSets, etc. An example might be you adding a new custom Backup resource whose main purpose is to do a scheduled cron job to upload backups to a desired target storage solution.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://theddy.dev/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Demystifying Kubernetes `controller-runtime`",
      "item": "https://theddy.dev/posts/controller-runtime/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Demystifying Kubernetes `controller-runtime`",
  "name": "Demystifying Kubernetes \u0060controller-runtime\u0060",
  "description": "If you\u0026rsquo;re like me and just starting your Kubernetes journey, you\u0026rsquo;ll likely need to write an Operator to manage your custom resources. Kubernetes offers a high-level Go framework called controller-runtime for building such operators; frameworks like Kubebuilder are built on top of it. What do I mean by custom resources? Well, anything that you would create which is not part of the Kubernetes well-known built-in resources - Pods, Deployments, ReplicaSets, etc. An example might be you adding a new custom Backup resource whose main purpose is to do a scheduled cron job to upload backups to a desired target storage solution.\n",
  "keywords": [
    "k8s", "kubernetes", "operator", "controller-runtime"
  ],
  "articleBody": "If you’re like me and just starting your Kubernetes journey, you’ll likely need to write an Operator to manage your custom resources. Kubernetes offers a high-level Go framework called controller-runtime for building such operators; frameworks like Kubebuilder are built on top of it. What do I mean by custom resources? Well, anything that you would create which is not part of the Kubernetes well-known built-in resources - Pods, Deployments, ReplicaSets, etc. An example might be you adding a new custom Backup resource whose main purpose is to do a scheduled cron job to upload backups to a desired target storage solution.\nController vs Operator Controller = logic that keeps the actual state aligned with the desired state.\nOperator = Controller + Custom Resource (CRD) + Domain Knowledge\nIn this guide, we will focus on understanding the components behind controller-runtime and what capabilities it has to offer. Where does it fit the whole kubernetes picture? What capabilities does it provide of write operators?\ncontroller-runtime dependencies What does the controller-runtime depend on? The main thing that concerns us is the API Machinery - \"k8s.io/apimachinery\". We cover the relevant parts of API Machinery later, so you understand the types used without losing focus on the main topic.\nController runtime The controller runtime is a high-level framework for building controllers and operators in Go - built on top of API Machinery. It provides:\nA Manager (lifecycle \u0026 dependency injection) Controllers and Reconcilers A unified Client (reads from cache, writes to API) - a Kubernetes API client Shared Caches (informers under the hood) Support for webhooks, leader election, and metrics Flow of controller-runtime event processing\nLet’s dive deep in each component.\nManager Kubernetes controllers need a shared environment. As we need a consistent and up-to-date view of the cluster, a shared environment means that multiple controllers (or multiple parts of the same controller) operate within a common set of shared parts — like caches, clients, schemes, and configuration.\nOne Client that uses the shared informer cache One Scheme for object type conversions One Recorder for observability - used to generate Kubernetes events One Config (the REST client configuration) One APIReader for uncached reads One metrics endpoint which exposes metrics by default on /metrics (used by Prometheus). One healthz/readyz probe - endpoints to integrate with Kubernetes liveness/readiness checks. One (optional) Leader Election so that only one instance actively reconciles at a time The Manager centralizes them, then injects them into every controller or runnable that needs them.\nDependency injection means we don’t create our dependencies ourselves, we receive them from something else that manages their lifecycle. Instead of the controllers manually constructing clients, caches, recorders, etc., the Manager creates them once, shares them across all controllers, and injects them into each component.\nIn Go, controller-runtime doesn’t use a reflection-based DI framework like Java’s Spring - it uses struct fields and interfaces to achieve DI statically.\nEach controller’s Reconciler usually looks like this:\ntype MyReconciler struct { client.Client Scheme *runtime.Scheme } Then in main.go, it wires it up like this:\nreconciler := \u0026controllers.MyReconciler{ Client: mgr.GetClient(), Scheme: mgr.GetScheme(), } if err := reconciler.SetupWithManager(mgr); err != nil { log.Fatal(err) } Client We need a way to interact with our cluster. The k8s.io/client-go package provides the tools to create a client. The controller-runtime leverages it to create a more robust unified client.\n“Unified” = single interface for cached reads and direct writes, avoiding the need to use separate client-go constructs.\nWhen we create a Manager, it will automatically build a Client and inject it into our controllers.\nmgr, _ := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{ Scheme: scheme, }) myReconciler := \u0026controllers.MyReconciler{ Client: mgr.GetClient(), // \u003c-- the client is available, can be used in other controllers as well } Read flow:\npod := \u0026corev1.Pod{} err := r.Client.Get(ctx, client.ObjectKey{Name: \"mypod\", Namespace: \"default\"}, pod) it’s using the Client to get the Pod object - usually from the cache.\nWrite flow:\nr.Client.Update(ctx, pod) it’s using the Client to write the updated Pod back to the Kubernetes API server.\nCache/Informer Cache in controller-runtime is an in-memory store of Kubernetes objects. It keeps copies of resources (Pods, Deployments, CRs, etc.) so our controllers can read quickly without hitting the API server every time.\nIn controller-runtime, caches are backed by informers, which watch Kubernetes resources and keep local copies up-to-date. This allows controllers to read from the cache for speed instead of querying the API server directly.\nInformer offer an elegant solution, acting as a smart filter between the controller and the Kubernetes API server. It “informs” our controller about changes in resources. Specifically, it:\nWatches the Kubernetes API for a particular resource type. Keeps the cache updated with the latest state. Triggers events (Add, Update, Delete) on any resource change, so our controller can react. Due to the informer, our controller will know that something has changed without constantly polling the KAPI.\nBehind the scenes, here is what the informer client does (ref):\nOn initialization, the Informer sends a LIST request to fetch all related resources in the cluster - i.e. Pods. Because the Informer’s cache starts out empty, all returned Pods are treated as “new” and passed to AddFunc. This response includes a resourceVersion marker, which is used in the next step. Importantly, the Informer stores returned Pods in its in-memory cache, which is kept up-to-date using events from the WATCH below. The Informer then sends a WATCH request, which subscribes to all Pod updates that happen after the resourceVersion marker. Pod creations are passed to AddFunc, deletions to DeleteFunc, and modifications to UpdateFunc. Reconciler WorkQueue The queue is an internal work queue that holds “reconciliation requests” - it references to Kubernetes objects that need to be reconciled. This is a thread-safe queue for storing items (usually ctrl.Requests). When an event occurs (create, update, delete) that affects a watched object, the controller enqueues a request for the Reconciler to process. The Reconciler then pulls items from the queue one at a time (or in parallel) and runs the Reconcile() function.\nThe Queue properties:\nEvent-driven: the queue is populated by informers whenever a relevant change happens. Rate-limiting: prevents overloading the controller. Error Backoff: it can retry failed reconciliations using backoff, preventing “hot” loops when errors occur. Deduplication: if multiple events happen for the same object before it’s processed, the queue usually coalesces them into a single reconciliation request. Order isn’t guaranteed: Items are generally processed in FIFO order, but because of retries and concurrency, exact ordering isn’t guaranteed. Reconciler A Reconciler is the core of a controller - the logic that defines what to do when a watched Kubernetes object changes. It implements:\ntype Reconciler interface { Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) } Lets check the signature: ctx context.Context - Used to handle timeouts, cancellations, and deadlines (especially during shutdown).\nreq ctrl.Request - Carries metadata about which object needs reconciling:\ntype Request struct { NamespacedName types.NamespacedName // object represented by {namespace str, name str} } This identifies a single object instance (like \"backup-ns/my-backup\").\nReturns -\u003e (ctrl.Result, error)\nReturn Value Meaning ctrl.Result{} Reconciliation successful - don’t requeue. ctrl.Result{Requeue: true} (deprecated) If the error is nil and result.RequeueAfter is zero and result.Requeue is true, the request will be requeued using exponential backoff. ctrl.Result{RequeueAfter: 10 * time.Second} Re-run after the specified delay. error != nil Error - requeue with backoff mechanism (skip if terminal error). Ignores ctrl.Result. This mechanism lets us control how often reconciliation runs and how errors are retried.\nSo Reconcile() is not a loop we write - it’s a callback triggered by events - it’s event-driven.\nThe primary resource changes (e.g., a CRD or Deployment). A dependent resource changes (e.g., Pod, Service, etc.). A manual requeue or RequeueAfter is triggered. The system detects a transient error and retries. Example in code:\nfunc (r *MyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) { // Read the object from cache myObj := \u0026myv1.MyResource{} if err := r.Client.Get(ctx, req.NamespacedName, myObj); err != nil { return ctrl.Result{}, client.IgnoreNotFound(err) } // Business logic: ensure a Deployment exists for this resource desired := newDeploymentForMyResource(myObj) if err := ctrl.SetControllerReference(myObj, desired, r.Scheme); err != nil { return ctrl.Result{}, err } // Apply the desired Deployment if err := r.Client.Create(ctx, desired); err != nil \u0026\u0026 !apierrors.IsAlreadyExists(err) { return ctrl.Result{}, err } return ctrl.Result{}, nil } API Machinery API Machinery is the foundation that defines what Kubernetes objects are and how they are encoded and handled. It tells Kubernetes how to understand, version, and serialize objects.\nThis is the core library of Kubernetes - the low-level building blocks that make the Kubernetes API function.\nIt handles all the important tasks such as:\nSerialization and deserialization (JSON \u003c-\u003e Go structs) Type registration (Scheme, GroupVersionKind) Metadata (ObjectMeta, TypeMeta) Versioning and conversion logic Deep copying and object interfaces REST resource identification (GroupVersionResource, etc.) When we define a Kubernetes object, we specify its TypeMeta (Kind and APIVersion - needed for Serialization, deserialization, API routing).\nEvery Kubernetes object also has an ObjectMeta, to define its uniqueness, leveraged by the object lifecycle and metadata tracking.\nThe full identifier of a Kubernetes API object is the GroupVersionResource commonly written as group/version/resource (GVR) triple: example - group:apps, version: v1, resource: deployment.\nKey packages of API Machinery:\nruntime - defines runtime.Object, Scheme, and type registration. schema - defines GroupVersion, GroupKind, GroupResource, etc. metav1 - defines metadata structs like ObjectMeta, ListMeta, TypeMeta. util/runtime, util/validation - utility helpers. What is a Schema actually? A Schema (represented by runtime.Scheme in Go) defines how objects of different types are recognized, versioned, and converted. It acts as a registry of all known Kubernetes types in our controller.\nWhen we register a type with a Scheme, we are actually saying:\n“This Go struct represents a Kubernetes resource.” “Here’s its group, version, and kind (GVK).” “Here’s how to convert it between versions if needed.” The Scheme is crucial because it allows our operators to:\nEncode and decode objects to/from JSON or YAML. Identify an object’s type when reading from the API or cache. Support version conversions when our CRD evolves. Without a Scheme, our controller wouldn’t know how to handle our custom resources properly, and most controller-runtime operations like Get, List, or Create would fail.\nUseful Reads Demystifying Kubernetes Informers Kubernetes Informers are so easy… to misuse! ",
  "wordCount" : "1692",
  "inLanguage": "en",
  "datePublished": "2025-10-09T18:15:00+03:00",
  "dateModified": "2025-10-09T18:15:00+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://theddy.dev/posts/controller-runtime/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Theddy Dev Space",
    "logo": {
      "@type": "ImageObject",
      "url": "https://theddy.dev/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://theddy.dev/" accesskey="h" title="Theddy Dev Space (Alt + H)">Theddy Dev Space</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://theddy.dev/" title="Theddy Dev Space">
                    <span>home</span>
                </a>
            </li>
            <li>
                <a href="https://theddy.dev/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://theddy.dev/about/" title="about">
                    <span>about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://theddy.dev/">Home</a>&nbsp;»&nbsp;<a href="https://theddy.dev/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Demystifying Kubernetes `controller-runtime`
    </h1>
    <div class="post-meta"><span title='2025-10-09 18:15:00 +0300 EEST'>October 9, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1692 words

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#controller-vs-operator">Controller vs Operator</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#controller-runtime-dependencies"><code>controller-runtime</code> dependencies</a></li>
    <li><a href="#controller-runtime">Controller runtime</a>
      <ul>
        <li>
          <ul>
            <li><a href="#manager">Manager</a></li>
            <li><a href="#client">Client</a></li>
            <li><a href="#cacheinformer">Cache/Informer</a></li>
            <li><a href="#reconciler-workqueue">Reconciler WorkQueue</a></li>
            <li><a href="#reconciler">Reconciler</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#api-machinery">API Machinery</a>
      <ul>
        <li>
          <ul>
            <li><a href="#what-is-a-schema-actually">What is a <code>Schema</code> actually?</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#useful-reads">Useful Reads</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>If you&rsquo;re like me and just starting your Kubernetes journey, you&rsquo;ll likely need to write an <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">Operator</a> to manage your <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">custom resources</a>. Kubernetes offers a high-level Go framework called <a href="https://github.com/kubernetes-sigs/controller-runtime"><code>controller-runtime</code></a> for building such operators; frameworks like <a href="https://book.kubebuilder.io/">Kubebuilder</a>  are built on top of it. What do I mean by custom resources? Well, anything that you would create which is not part of the Kubernetes well-known built-in resources - Pods, Deployments, ReplicaSets, etc. An example might be you adding a new custom <code>Backup</code> resource whose main purpose is to do a scheduled cron job to upload backups to a desired target storage solution.</p>
<h4 id="controller-vs-operator">Controller vs Operator<a hidden class="anchor" aria-hidden="true" href="#controller-vs-operator">#</a></h4>
<blockquote>
<p><strong>Controller</strong> = logic that keeps the actual state aligned with the desired state.</p></blockquote>
<blockquote>
<p><strong>Operator</strong> = Controller + Custom Resource (CRD) + Domain Knowledge</p></blockquote>
<p>In this guide, we will focus on understanding the components behind <code>controller-runtime</code> and what capabilities it has to offer. Where does it fit the whole kubernetes picture? What capabilities does it provide of write operators?</p>
<hr>
<h2 id="controller-runtime-dependencies"><code>controller-runtime</code> dependencies<a hidden class="anchor" aria-hidden="true" href="#controller-runtime-dependencies">#</a></h2>
<p>What does the controller-runtime depend on? The main thing that concerns us is the API Machinery - <code>&quot;k8s.io/apimachinery&quot;</code>. We cover the relevant parts of API Machinery later, so you understand the types used without losing focus on the main topic.</p>
<h2 id="controller-runtime">Controller runtime<a hidden class="anchor" aria-hidden="true" href="#controller-runtime">#</a></h2>
<p>The controller runtime is a <strong>high-level framework</strong> for building <strong>controllers and operators</strong> in Go - built <em>on top of API Machinery</em>. It provides:</p>
<ul>
<li>A <strong>Manager</strong> (lifecycle &amp; dependency injection)</li>
<li><strong>Controllers</strong> and <strong>Reconcilers</strong></li>
<li>A unified <strong>Client</strong> (reads from cache, writes to API) - a <strong>Kubernetes API client</strong></li>
<li>Shared <strong>Caches</strong> (informers under the hood)</li>
<li>Support for <strong>webhooks</strong>, <strong>leader election</strong>, and <strong>metrics</strong></li>
</ul>
<p><img loading="lazy" src="/resources/controller-runtime-arch.png">
<em>Flow of controller-runtime event processing</em></p>
<p>Let&rsquo;s dive deep in each component.</p>
<h4 id="manager">Manager<a hidden class="anchor" aria-hidden="true" href="#manager">#</a></h4>
<p>Kubernetes controllers need a <strong>shared environment</strong>. As we need a consistent and up-to-date view of the cluster, a shared environment means that multiple controllers (or multiple parts of the same controller) operate within a common set of shared parts — like caches, clients, schemes, and configuration.</p>
<ul>
<li>One <a href="#client"><code>Client</code></a> that uses the shared informer cache</li>
<li>One <a href="#what-is-a-schema-actually"><code>Scheme</code></a> for object type conversions</li>
<li>One <code>Recorder</code> for observability - used to generate Kubernetes events</li>
<li>One <code>Config</code> (the REST client configuration)</li>
<li>One <code>APIReader</code> for uncached reads</li>
<li>One <code>metrics</code> endpoint which exposes metrics by default on <code>/metrics</code> (used by Prometheus).</li>
<li>One <code>healthz/readyz</code> probe - endpoints to integrate with Kubernetes liveness/readiness checks.</li>
<li>One (optional) <code>Leader Election</code> so that only one instance actively reconciles at a time</li>
</ul>
<p>The <strong>Manager</strong> centralizes them, then <strong>injects</strong> them into every controller or runnable that needs them.</p>
<p>Dependency injection means we don&rsquo;t create our dependencies ourselves, we receive them from something else that manages their lifecycle. Instead of the controllers manually constructing clients, caches, recorders, etc., the Manager creates them once, shares them across all controllers, and injects them into each component.</p>
<p>In Go, controller-runtime doesn&rsquo;t use a reflection-based DI framework like Java&rsquo;s Spring - it uses <strong>struct fields</strong> and <strong>interfaces</strong> to achieve DI <em>statically</em>.</p>
<p>Each controller&rsquo;s Reconciler usually looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyReconciler</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Client</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Scheme</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Scheme</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then in <code>main.go</code>, it wires it up like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">reconciler</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">controllers</span>.<span style="color:#a6e22e">MyReconciler</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Client</span>: <span style="color:#a6e22e">mgr</span>.<span style="color:#a6e22e">GetClient</span>(),
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Scheme</span>: <span style="color:#a6e22e">mgr</span>.<span style="color:#a6e22e">GetScheme</span>(),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reconciler</span>.<span style="color:#a6e22e">SetupWithManager</span>(<span style="color:#a6e22e">mgr</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="client">Client<a hidden class="anchor" aria-hidden="true" href="#client">#</a></h4>
<p>We need a way to interact with our cluster. The <code>k8s.io/client-go</code> package provides the tools to create a client. The <code>controller-runtime</code> leverages it to create a more robust <strong>unified</strong> client.</p>
<blockquote>
<p>&ldquo;Unified&rdquo; = single interface for cached reads and direct writes, avoiding the need to use separate client-go constructs.</p></blockquote>
<p>When we create a Manager, it will automatically build a <code>Client</code> and inject it into our controllers.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">mgr</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">NewManager</span>(<span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">GetConfigOrDie</span>(), <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Options</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Scheme</span>: <span style="color:#a6e22e">scheme</span>,
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">myReconciler</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">controllers</span>.<span style="color:#a6e22e">MyReconciler</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Client</span>: <span style="color:#a6e22e">mgr</span>.<span style="color:#a6e22e">GetClient</span>(),  <span style="color:#75715e">// &lt;-- the client is available, can be used in other controllers as well</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Read flow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">pod</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">corev1</span>.<span style="color:#a6e22e">Pod</span>{} <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Client</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">ObjectKey</span>{<span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;mypod&#34;</span>, <span style="color:#a6e22e">Namespace</span>: <span style="color:#e6db74">&#34;default&#34;</span>}, <span style="color:#a6e22e">pod</span>)
</span></span></code></pre></div><p>it&rsquo;s using the <strong>Client</strong> to <em>get</em> the Pod object - usually from the cache.</p>
<p>Write flow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Client</span>.<span style="color:#a6e22e">Update</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">pod</span>)
</span></span></code></pre></div><p>it&rsquo;s using the <strong>Client</strong> to <em>write</em> the updated Pod back to the <strong>Kubernetes API server</strong>.</p>
<h4 id="cacheinformer">Cache/Informer<a hidden class="anchor" aria-hidden="true" href="#cacheinformer">#</a></h4>
<p><strong>Cache</strong> in <code>controller-runtime</code> is an in-memory store of Kubernetes objects. It keeps copies of resources (Pods, Deployments, CRs, etc.) so our controllers can read quickly without hitting the API server every time.</p>
<p>In <code>controller-runtime</code>, caches are backed by informers, which watch Kubernetes resources and keep local copies up-to-date. This allows controllers to read from the cache for speed instead of querying the API server directly.</p>
<p><strong>Informer</strong> offer an elegant solution, acting as a smart filter between the controller and the Kubernetes API server. It &ldquo;informs&rdquo; our controller about changes in resources. Specifically, it:</p>
<ul>
<li>Watches the Kubernetes API for a particular resource type.</li>
<li>Keeps the cache updated with the latest state.</li>
<li>Triggers events (Add, Update, Delete) on <em>any</em> resource change, so our controller can react.</li>
</ul>
<p>Due to the informer, our controller will know that something has changed without constantly polling the KAPI.</p>
<p>Behind the scenes, here is what the informer client does (<a href="https://render.com/blog/kubernetes-informers">ref</a>):</p>
<ol>
<li>On initialization, the Informer sends a <code>LIST</code> request to fetch all related resources in the cluster - i.e. Pods. Because the Informer&rsquo;s cache starts out empty, all returned Pods are treated as &ldquo;new&rdquo; and passed to AddFunc.
<ul>
<li>This response includes a resourceVersion marker, which is used in the next step.</li>
<li>Importantly, the Informer stores returned Pods in its in-memory cache, which is kept up-to-date using events from the <code>WATCH</code> below.</li>
</ul>
</li>
<li>The Informer then sends a <code>WATCH</code> request, which <em>subscribes</em> to all Pod updates that happen after the resourceVersion marker.
<ul>
<li>Pod creations are passed to AddFunc, deletions to DeleteFunc, and modifications to UpdateFunc.</li>
</ul>
</li>
</ol>
<h4 id="reconciler-workqueue">Reconciler WorkQueue<a hidden class="anchor" aria-hidden="true" href="#reconciler-workqueue">#</a></h4>
<p>The queue is an internal <em>work queue</em> that holds &ldquo;reconciliation requests&rdquo; - it references to Kubernetes objects that need to be reconciled. This is a thread-safe queue for storing items (usually <code>ctrl.Requests</code>). When an event occurs (create, update, delete) that affects a watched object, the controller enqueues a request for the Reconciler to process. The Reconciler then pulls items from the queue one at a time (or in parallel) and runs the <code>Reconcile()</code> function.</p>
<p>The Queue properties:</p>
<ul>
<li>Event-driven: the queue is populated by informers whenever a relevant change happens.</li>
<li>Rate-limiting: prevents overloading the controller.</li>
<li>Error Backoff: it can retry failed reconciliations using backoff, preventing &ldquo;hot&rdquo; loops when errors occur.</li>
<li>Deduplication: if multiple events happen for the same object before it’s processed, the queue usually coalesces them into a single reconciliation request.</li>
<li>Order isn&rsquo;t guaranteed: Items are generally processed in FIFO order, but because of retries and concurrency, exact ordering isn&rsquo;t guaranteed.</li>
</ul>
<h4 id="reconciler">Reconciler<a hidden class="anchor" aria-hidden="true" href="#reconciler">#</a></h4>
<p>A <strong>Reconciler</strong> is the core of a controller - the logic that defines <strong>what to do</strong> when a watched Kubernetes object changes.
It implements:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Reconciler</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Reconcile</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">req</span> <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Request</span>) (<span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Result</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Lets check the signature:
<code>ctx context.Context</code> - Used to handle timeouts, cancellations, and deadlines (especially during shutdown).</p>
<p><code>req ctrl.Request</code> - Carries metadata about <strong>which object</strong> needs reconciling:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Request</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">NamespacedName</span> <span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">NamespacedName</span> <span style="color:#75715e">// object represented by {namespace str, name str}</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This identifies a <em>single object instance</em> (like <code>&quot;backup-ns/my-backup&quot;</code>).</p>
<p>Returns -&gt; <code>(ctrl.Result, error)</code></p>
<table>
  <thead>
      <tr>
          <th>Return Value</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>ctrl.Result{}</code></td>
          <td>Reconciliation successful - don&rsquo;t requeue.</td>
      </tr>
      <tr>
          <td><code>ctrl.Result{Requeue: true}</code></td>
          <td>(deprecated) If the error is nil and result.RequeueAfter is zero and result.Requeue is true, the request will be requeued using exponential backoff.</td>
      </tr>
      <tr>
          <td><code>ctrl.Result{RequeueAfter: 10 * time.Second}</code></td>
          <td>Re-run after the specified delay.</td>
      </tr>
      <tr>
          <td><code>error != nil</code></td>
          <td>Error - requeue with backoff mechanism (skip if terminal error). Ignores ctrl.Result.</td>
      </tr>
  </tbody>
</table>
<p>This mechanism lets us control <em>how often</em> reconciliation runs and how errors are retried.</p>
<p>So <code>Reconcile()</code> is not a loop we write - it&rsquo;s a <em>callback</em> triggered by events - it&rsquo;s <strong>event-driven</strong>.</p>
<ol>
<li>The <strong>primary resource</strong> changes (e.g., a CRD or Deployment).</li>
<li>A <strong>dependent resource</strong> changes (e.g., Pod, Service, etc.).</li>
<li>A <strong>manual requeue</strong> or <code>RequeueAfter</code> is triggered.</li>
<li>The system detects a transient error and retries.</li>
</ol>
<p>Example in code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MyReconciler</span>) <span style="color:#a6e22e">Reconcile</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">req</span> <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Request</span>) (<span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Result</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Read the object from cache</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myObj</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">myv1</span>.<span style="color:#a6e22e">MyResource</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Client</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">NamespacedName</span>, <span style="color:#a6e22e">myObj</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Result</span>{}, <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">IgnoreNotFound</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Business logic: ensure a Deployment exists for this resource</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">desired</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newDeploymentForMyResource</span>(<span style="color:#a6e22e">myObj</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">SetControllerReference</span>(<span style="color:#a6e22e">myObj</span>, <span style="color:#a6e22e">desired</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Scheme</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Result</span>{}, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Apply the desired Deployment</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Client</span>.<span style="color:#a6e22e">Create</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">desired</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">apierrors</span>.<span style="color:#a6e22e">IsAlreadyExists</span>(<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Result</span>{}, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Result</span>{}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="api-machinery">API Machinery<a hidden class="anchor" aria-hidden="true" href="#api-machinery">#</a></h2>
<p>API Machinery is the <strong>foundation</strong> that defines <em>what</em> Kubernetes objects are and <em>how</em> they are encoded and handled. It tells Kubernetes how to understand, version, and serialize objects.</p>
<p>This is the <strong>core library</strong> of Kubernetes - the low-level building blocks that make the Kubernetes API function.</p>
<p>It handles all the important tasks such as:</p>
<ul>
<li>Serialization and deserialization (JSON &lt;-&gt; Go structs)</li>
<li>Type registration (<code>Scheme</code>, <code>GroupVersionKind</code>)</li>
<li>Metadata (<code>ObjectMeta</code>, <code>TypeMeta</code>)</li>
<li>Versioning and conversion logic</li>
<li>Deep copying and object interfaces</li>
<li>REST resource identification (<code>GroupVersionResource</code>, etc.)</li>
</ul>
<p>When we define a Kubernetes object, we specify its <code>TypeMeta</code> (Kind and APIVersion - needed for Serialization, deserialization, API routing).</p>
<p>Every Kubernetes object also has an <code>ObjectMeta</code>, to define its uniqueness, leveraged by the object lifecycle and metadata tracking.</p>
<p>The full identifier of a Kubernetes API object is the <code>GroupVersionResource</code> commonly written as group/version/resource (GVR) triple: example - group:apps, version: v1, resource: deployment.</p>
<p><strong>Key packages of API Machinery:</strong></p>
<ul>
<li><code>runtime</code> - defines <code>runtime.Object</code>, <code>Scheme</code>, and type registration.</li>
<li><code>schema</code> - defines <code>GroupVersion</code>, <code>GroupKind</code>, <code>GroupResource</code>, etc.</li>
<li><code>metav1</code> - defines metadata structs like <code>ObjectMeta</code>, <code>ListMeta</code>, <code>TypeMeta</code>.</li>
<li><code>util/runtime</code>, <code>util/validation</code> - utility helpers.</li>
</ul>
<h4 id="what-is-a-schema-actually">What is a <code>Schema</code> actually?<a hidden class="anchor" aria-hidden="true" href="#what-is-a-schema-actually">#</a></h4>
<p>A <strong>Schema</strong> (represented by <code>runtime.Scheme</code> in Go) defines <strong>how objects of different types are recognized, versioned, and converted</strong>. It acts as a <strong>registry</strong> of all known Kubernetes types in our controller.</p>
<p>When we register a type with a Scheme, we are actually saying:</p>
<ul>
<li>&ldquo;This Go struct represents a Kubernetes resource.&rdquo;</li>
<li>&ldquo;Here&rsquo;s its group, version, and kind (GVK).&rdquo;</li>
<li>&ldquo;Here&rsquo;s how to convert it between versions if needed.&rdquo;</li>
</ul>
<p>The Scheme is crucial because it allows our operators to:</p>
<ol>
<li>Encode and decode objects to/from JSON or YAML.</li>
<li>Identify an object&rsquo;s type when reading from the API or cache.</li>
<li>Support version conversions when our CRD evolves.</li>
</ol>
<p>Without a Scheme, our controller wouldn&rsquo;t know how to handle our custom resources properly, and most controller-runtime operations like <code>Get</code>, <code>List</code>, or <code>Create</code> would fail.</p>
<h2 id="useful-reads">Useful Reads<a hidden class="anchor" aria-hidden="true" href="#useful-reads">#</a></h2>
<ul>
<li><a href="https://medium.com/@jeevanragula/demystifying-kubernetes-informer-streamlining-event-driven-workflows-955285166993">Demystifying Kubernetes Informers</a></li>
<li><a href="https://render.com/blog/kubernetes-informers">Kubernetes Informers are so easy&hellip; to misuse!</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://theddy.dev/tags/k8s/">K8s</a></li>
      <li><a href="https://theddy.dev/tags/kubernetes/">Kubernetes</a></li>
      <li><a href="https://theddy.dev/tags/operator/">Operator</a></li>
      <li><a href="https://theddy.dev/tags/controller-runtime/">Controller-Runtime</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
